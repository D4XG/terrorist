{"version":3,"sources":["reroute.js"],"names":["assert","require","Net","routing","enabled","findTargetPort","hostname","port","route","get","wildcard","replace","enableRerouting","connect","Socket","prototype","options","callback","hasNormalizedArgs","length","isNode8","Array","isArray","reroutedOptions","rerouteOptions","call","apply","arguments","host","module","exports","addRoute","source","target","sourceHost","split","sourcePort","set"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAMA,SAAUC,QAAQ,QAAR,CAAhB;AACA,MAAMC,MAAUD,QAAQ,KAAR,CAAhB;;AAGA;AACA;AACA;AACA;AACA,MAAME,UAAU,mBAAhB;;AAEA;AACA;AACA,IAAMC,UAAU,KAAhB;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,IAAlC,EAAwC;AACtC,MAAI,CAACD,QAAL,EACE,OAAO,IAAP;;AAEF,QAAME,QAAQL,QAAQM,GAAR,CAAYH,QAAZ,CAAd;AACA,MAAIE,KAAJ,EACE,OAAOA,MAAMD,IAAN,CAAP;;AAEF;AACA;AACA,QAAMG,WAAWJ,SAASK,OAAT,CAAiB,qBAAjB,EAAwC,IAAxC,CAAjB;AACA,MAAID,aAAa,IAAjB,EACE,OAAOL,eAAeK,QAAf,EAAyBH,IAAzB,CAAP;AACH;;AAGD;AACA,SAASK,eAAT,GAA2B;AACzB,MAAIR,OAAJ,EACE;AACFA,YAAU,IAAV;;AAEA,QAAMS,UAAUX,IAAIY,MAAJ,CAAWC,SAAX,CAAqBF,OAArC;AACAX,MAAIY,MAAJ,CAAWC,SAAX,CAAqBF,OAArB,GAA+B,UAASG,OAAT,EAAkBC,QAAlB,EAA4B;AACzD,UAAMC,oBAAoB,mCAAgC,qCAA6BF,OAA7B,EAAsCG,MAAtC,GAA+C,CAAzG;AACA,UAAMC,UAAoBC,MAAMC,OAAN,CAAcN,OAAd,KAA0BE,iBAApD;AACA,QAAIE,OAAJ,EAAa;AACX,YAAMG,kBAAkBC,eAAeR,QAAQ,CAAR,CAAf,CAAxB;AACAC,iBAAwBD,QAAQ,CAAR,CAAxB;AACA,aAAOH,QAAQY,IAAR,CAAa,IAAb,EAAmBF,eAAnB,EAAoCN,QAApC,CAAP;AACD,KAJD,MAIO,IAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AACtC,YAAMO,kBAAkBC,eAAeR,OAAf,CAAxB;AACA,aAAOH,QAAQY,IAAR,CAAa,IAAb,EAAmBF,eAAnB,EAAoCN,QAApC,CAAP;AACD,KAHM,MAIL,OAAOJ,QAAQa,KAAR,CAAc,IAAd,EAAoBC,SAApB,CAAP;AACH,GAZD;AAaD;;AAGD,SAASH,cAAT,CAAwBR,OAAxB,EAAiC;AAC/B,QAAMT,OAAOF,eAAeW,QAAQY,IAAvB,EAA6BZ,QAAQT,IAArC,CAAb;AACA,MAAIA,IAAJ,EACE,OAAO,sBAAc,EAAd,EAAkBS,OAAlB,EAA2B,EAAEY,MAAM,WAAR,EAAqBrB,IAArB,EAA3B,CAAP,CADF,KAGE,OAAOS,OAAP;AACH;;AAGD;AACA;AACAa,OAAOC,OAAP,GAAiB,SAASC,QAAT,CAAkBC,MAAlB,EAA0BC,MAA1B,EAAkC;AACjDjC,SAAOgC,MAAP,EAAe,gEAAf;AACA,QAAME,aAAgBF,OAAOG,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAtB;AACA,QAAMC,aAAgBJ,OAAOG,KAAP,CAAa,GAAb,EAAkB,CAAlB,KAAwB,EAA9C;AACA,QAAM3B,QAAgBL,QAAQM,GAAR,CAAYyB,UAAZ,KAA2B,EAAjD;AACA/B,UAAQkC,GAAR,CAAYH,UAAZ,EAAwB1B,KAAxB;AACA,MAAI,CAACA,MAAM4B,UAAN,CAAL,EACE5B,MAAM4B,UAAN,IAAoBH,MAApB;AACFjC,SAAOQ,MAAM4B,UAAN,MAAsBH,MAA7B,EACQ,6BAA4BD,MAAO,OAAMxB,MAAM4B,UAAN,CAAkB,EADnE;;AAGA;AACAxB;AACD,CAbD","file":"reroute.js","sourcesContent":["// Domain routing and port forwarding\n//\n// Used for mapping hosts and domains to localhost, so you can open TCP\n// connections with friendly hostnames to test against the local server.\n//\n// Can also map any source port to any destination port, so you can use port 80\n// to access localhost server running on unprivileged port.\n\n\nconst assert  = require('assert');\nconst Net     = require('net');\n\n\n// Routing table.\n//\n// key   - Source host name or wildcard (e.g. \"example.com\", \"*.example.com\")\n// value - Object that maps source port to target port\nconst routing = new Map();\n\n// Flip this from enableRerouting() so we only inject our code into\n// Socket.connect once.\nlet   enabled = false;\n\n\n// If there's a route for host/port, returns destination port number.\n//\n// Called recursively to handle wildcards.  Starting with the host\n// www.example.com, it will attempt to match routes from most to least specific:\n//\n//   www.example.com\n// *.www.example.com\n//     *.example.com\n//             *.com\nfunction findTargetPort(hostname, port) {\n  if (!hostname)\n    return null;\n\n  const route = routing.get(hostname);\n  if (route)\n    return route[port];\n\n  // This will first expand www.hostname.com to *.www.hostname.com,\n  // then contract it to *.hostname.com, *.com and finally *.\n  const wildcard = hostname.replace(/^(\\*\\.[^.]+(\\.|$))?/, '*.');\n  if (wildcard !== '*.')\n    return findTargetPort(wildcard, port);\n}\n\n\n// Called once to hack Socket.connect\nfunction enableRerouting() {\n  if (enabled)\n    return;\n  enabled = true;\n\n  const connect = Net.Socket.prototype.connect;\n  Net.Socket.prototype.connect = function(options, callback) {\n    const hasNormalizedArgs = Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(options).length > 0;\n    const isNode8           = Array.isArray(options) && hasNormalizedArgs;\n    if (isNode8) {\n      const reroutedOptions = rerouteOptions(options[0]);\n      callback              = options[1];\n      return connect.call(this, reroutedOptions, callback);\n    } else if (typeof options === 'object') {\n      const reroutedOptions = rerouteOptions(options);\n      return connect.call(this, reroutedOptions, callback);\n    } else\n      return connect.apply(this, arguments);\n  };\n}\n\n\nfunction rerouteOptions(options) {\n  const port = findTargetPort(options.host, options.port);\n  if (port)\n    return Object.assign({}, options, { host: 'localhost', port });\n  else\n    return options;\n}\n\n\n// source - Hostname or host:port (default to port 80)\n// target - Target port number\nmodule.exports = function addRoute(source, target) {\n  assert(source, 'Expected source address of the form \"host:port\" or just \"host\"');\n  const sourceHost    = source.split(':')[0];\n  const sourcePort    = source.split(':')[1] || 80;\n  const route         = routing.get(sourceHost) || {};\n  routing.set(sourceHost, route);\n  if (!route[sourcePort])\n    route[sourcePort] = target;\n  assert(route[sourcePort] === target,\n         `Already have routing from ${source} to ${route[sourcePort]}`);\n\n  // Enable Socket.connect routing\n  enableRerouting();\n};\n"]}