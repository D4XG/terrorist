{"version":3,"sources":["eventloop.js"],"names":["assert","require","EventEmitter","idlUtils","Timeout","constructor","eventQueue","fn","delay","remove","Math","max","handle","global","setTimeout","fire","bind","next","Date","now","enqueue","eventLoop","emit","window","_evaluate","error","stop","clearTimeout","Interval","interval","fireInProgress","setInterval","clearInterval","EventQueue","browser","_eventLoop","queue","expecting","timers","eventSources","nextTimerHandle","destroy","timer","eventSource","close","expected","frames","filter","frame","_eventQueue","length","push","run","waitForCompletion","dequeue","shift","childFn","http","request","callback","done","fetch","then","response","catch","onerror","event","document","createEvent","initEvent","message","dispatchEvent","addEventSource","args","apply","map","concat","sort","Infinity","module","exports","EventLoop","active","running","waiting","wait","waitDuration","completionFunction","timeout","timeoutOn","ontick","activeWindow","documentElement","waitFor","completed","removeListener","Error","on","once","dump","output","process","stdout","write","createEventQueue","setActiveWindow","jsdomQueue","implForWrapper","_queue","tail","resume","isFinite"],"mappings":"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","file":"eventloop.js","sourcesContent":["// The event loop.\n//\n// Each browser has an event loop, which processes asynchronous events like\n// loading pages and resources, XHR, timeouts and intervals, etc. These are\n// procesed in order.\n//\n// The purpose of the event loop is two fold:\n// - To get events processed in the right order for the active window (and only\n//   the active window)\n// - And to allow the code to wait until all events have been processed\n//   (browser.wait, .visit, .pressButton, etc)\n//\n// The event loop has one interesting method: `wait`.\n//\n// Each window maintains its own event queue. Its interesting methods are\n// `enqueue`, `http`, `dispatch` and the timeout/interval methods.\n\n\nconst assert            = require('assert');\nconst { EventEmitter }  = require('events');\nconst { idlUtils }    = require('./dom/impl');\n\n\n// Wrapper for a timeout (setTimeout)\nclass Timeout {\n\n  // eventQueue - Reference to the event queue\n  // fn         - When timer fires, evaluate this function\n  // delay      - How long to wait\n  // remove     - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js timeout handle\n  // next    - When is this timer firing next\n  constructor(eventQueue, fn, delay, remove) {\n    this.eventQueue   = eventQueue;\n    this.fn           = fn;\n    this.delay        = Math.max(delay || 0, 0);\n    this.remove       = remove;\n\n    this.handle       = global.setTimeout(this.fire.bind(this), this.delay);\n    this.next         = Date.now() + this.delay;\n  }\n\n  fire() {\n    // In response to Node firing setTimeout, but only allowed to process this\n    // event during a wait()\n    this.eventQueue.enqueue(()=> {\n      const { eventLoop } = this.eventQueue;\n      eventLoop.emit('setTimeout', this.fn, this.delay);\n      try {\n        this.eventQueue.window._evaluate(this.fn);\n      } catch (error) {\n        eventLoop.emit('error', error);\n      }\n    });\n    this.remove();\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearTimeout(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Wrapper for an interval (setInterval)\nclass Interval {\n\n  // eventQueue - Reference to the event queue\n  // fn        - When timer fires, evaluate this function\n  // interval  - Interval between firing\n  // remove    - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js interval handle\n  // next    - When is this timer firing next\n  constructor(eventQueue, fn, interval, remove) {\n    this.eventQueue     = eventQueue;\n    this.fn             = fn;\n    this.interval       = Math.max(interval || 0, 0);\n    this.remove         = remove;\n    this.fireInProgress = false;\n    this.handle         = global.setInterval(this.fire.bind(this), this.interval);\n    this.next           = Date.now() + this.interval;\n  }\n\n  fire() {\n    // In response to Node firing setInterval, but only allowed to process this\n    // event during a wait()\n    this.next = Date.now() + this.interval;\n\n    // setInterval events not allowed to overlap, don't queue two at once\n    if (this.fireInProgress)\n      return;\n    this.fireInProgress = true;\n    this.eventQueue.enqueue(()=> {\n      this.fireInProgress = false;\n\n      const { eventLoop } = this.eventQueue;\n      eventLoop.emit('setInterval', this.fn, this.interval);\n      try {\n        this.eventQueue.window._evaluate(this.fn);\n      } catch (error) {\n        eventLoop.emit('error', error);\n      }\n    });\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearInterval(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Each window has an event queue that holds all pending events.  Various\n// browser features push new functions into the queue (e.g. process XHR\n// response, setTimeout fires).  The event loop is responsible to pop these\n// events from the queue and run them, but only during browser.wait().\n//\n// In addition, the event queue keeps track of all outstanding timers\n// (setTimeout/setInterval) so it can return consecutive handles and clean them\n// up during window.destroy().\n//\n// In addition, we keep track of when the browser is expecting an event to\n// arrive in the queue (e.g. sent XHR request, expecting an event to process the\n// response soon enough).  The event loop uses that to determine if it's worth\n// waiting.\nclass EventQueue {\n\n  // Instance variables:\n  // browser          - Reference to the browser\n  // eventLoop        - Reference to the browser's event loop\n  // queue            - FIFO queue of functions to call\n  // expecting        - These are holding back the event loop\n  // timers           - Sparse array of timers (index is the timer handle)\n  // eventSources     - Additional sources for events (SSE, WS, etc)\n  // nextTimerHandle  - Value of next timer handler\n  constructor(window) {\n    this.window           = window;\n    this.browser          = window.browser;\n    this.eventLoop        = this.browser._eventLoop;\n    this.queue            = [];\n    this.expecting        = 0;\n    this.timers           = [];\n    this.eventSources     = [];\n    this.nextTimerHandle  = 1;\n  }\n\n\n  // Cleanup when we dispose of the window\n  destroy() {\n    if (!this.queue)\n      return;\n    this.queue = null;\n\n    for (let timer of this.timers)\n      if (timer)\n        timer.stop();\n    this.timers = null;\n\n    for (let eventSource of this.eventSources)\n      //if (eventSource)\n        eventSource.close();\n    this.eventSources = null;\n  }\n\n\n  // -- Events --\n\n  // Any events expected in the future?\n  get expected() {\n    return !!(this.expecting ||\n              Array.from(this.window.frames).filter(frame => frame._eventQueue.expected).length);\n  }\n\n  // Add a function to the event queue, to be executed in order.\n  enqueue(fn) {\n    assert(this.queue, 'This browser has been destroyed');\n    assert(typeof fn === 'function', 'eventLoop.enqueue called without a function');\n\n    if (fn) {\n      this.queue.push(fn);\n      this.eventLoop.run();\n    }\n  }\n\n\n  // Wait for completion.  Returns a completion function, event loop will remain\n  // active until the completion function is called;\n  waitForCompletion() {\n    ++this.expecting;\n    return ()=> {\n      --this.expecting;\n      setImmediate(()=> {\n        this.eventLoop.run();\n      });\n    };\n  }\n\n\n  // Event loop uses this to grab event from top of the queue.\n  dequeue() {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const fn = this.queue.shift();\n    if (fn)\n      return fn;\n    for (let frame of Array.from(this.window.frames)) {\n      let childFn = frame._eventQueue.dequeue();\n      if (childFn)\n        return childFn;\n    }\n    return null;\n  }\n\n\n  // Makes an HTTP request.\n  //\n  // request  - Request object\n  // callback - Called with Response object to process the response\n  //\n  // Because the callback is added to the queue, we can't use promises\n  http(request, callback) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const done = this.waitForCompletion();\n    this.window\n      .fetch(request)\n      .then((response)=> {\n        // We can't cancel pending requests, but we can ignore the response if\n        // window already closed\n        if (this.queue)\n          // This will get completion function to execute, e.g. to check a page\n          // before meta tag refresh\n          this.enqueue(()=> {\n            callback(null, response);\n          });\n      })\n      .catch((error)=> {\n        if (this.queue)\n          callback(error);\n      })\n      .then(done);\n  }\n\n  // Fire an error event.  Used by JSDOM patches.\n  onerror(error) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    this.eventLoop.emit('error', error);\n\n    const event = this.window.document.createEvent('Event');\n    event.initEvent('error', false, false);\n    event.message = error.message;\n    event.error = error;\n    this.window.dispatchEvent(event);\n  }\n\n\n  // -- EventSource --\n\n  addEventSource(eventSource) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    this.eventSources.push(eventSource);\n\n    const emit = eventSource.emit;\n    eventSource.emit = (...args)=> {\n      this.eventLoop.emit('serverEvent');\n      this.enqueue(()=> {\n        emit.apply(eventSource, args);\n      });\n    };\n  }\n\n\n  // -- Timers --\n\n  // Window.setTimeout\n  setTimeout(fn, delay = 0) {\n    assert(this.queue, 'This browser has been destroyed');\n    if (!fn)\n      return null;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    this.timers[handle] = new Timeout(this, fn, delay, ()=> {\n      delete this.timers[handle];\n    });\n    return handle;\n  }\n\n  // Window.clearTimeout\n  clearTimeout(handle) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Window.setInterval\n  setInterval(fn, interval = 0) {\n    assert(this.queue, 'This browser has been destroyed');\n    if (!fn)\n      return null;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    this.timers[handle] = new Interval(this, fn, interval, ()=> {\n      delete this.timers[handle];\n    });\n    return handle;\n  }\n\n  // Window.clearInterval\n  clearInterval(handle) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Returns the timestamp of the next timer event\n  get next() {\n    const timers  = this.timers.map(timer => timer.next);\n    const frames  = Array.from(this.window.frames).map(frame => frame._eventQueue.next);\n    return timers.concat(frames).sort()[0] || Infinity;\n  }\n\n}\n\n\n// The browser event loop.\n//\n// Each browser has one event loop that processes events from the queues of the\n// currently active window and its frames (child windows).\n//\n// The wait method is responsible to process all pending events.  It goes idle\n// once:\n// - There are no more events waiting in the queue (of the active window)\n// - There are no more timers waiting to fire (next -> Infinity)\n// - No future events are expected to arrive (e.g. in-progress XHR requests)\n//\n// The wait method will complete before the loop goes idle, if:\n// - Past the specified timeout\n// - The next scheduled timer is past the specified timeout\n// - The completio function evaluated to true\n//\n// While processing, the event loop emits the following events (on the browser\n// object):\n// tick(next) - Emitted after executing a single event; the argument is the\n//              expected duration until the next event (in ms)\n// idle       - Emitted when there are no more events (queued or expected)\n// error(err) - Emitted after an error\nmodule.exports = class EventLoop extends EventEmitter {\n\n  // Instance variables are:\n  // active    - Currently active window\n  // browser   - Reference to the browser\n  // running   - True when inside a run loop\n  // waiting   - Counts in-progess calls to wait (waiters?)\n  constructor(browser) {\n    super();\n    this.browser  = browser;\n    this.active   = null;\n    this.running  = false;\n    this.waiting  = 0;\n  }\n\n\n  // -- The wait function --\n\n  // Wait until one of these happen:\n  // 1. We run out of events to process; callback is called with null and false\n  // 2. The completion function evaluates to true; callback is called with null\n  //    and false\n  // 3. The time duration elapsed; callback is called with null and true\n  // 2. An error occurs; callback is called with an error\n  //\n  // Duration is specifies in milliseconds or string form (e.g. \"15s\").\n  //\n  // Completion function is called with the currently active window (may change\n  // during page navigation or form submission) and how long until the next\n  // event, and returns true to stop waiting, any other value to continue\n  // processing events.\n  //\n  //\n  // waitDuration       - How long to wait (ms)\n  // completionFunction - Returns true for early completion\n  wait(waitDuration, completionFunction, callback) {\n    assert(waitDuration, 'Wait duration required, cannot be 0');\n    const eventLoop = this;\n\n    ++eventLoop.waiting;\n    // Someone (us) just started paying attention, start processing events\n    if (eventLoop.waiting === 1)\n      setImmediate(()=> eventLoop.run());\n\n    // The timer fires when we waited long enough, we need timeoutOn to tell if\n    // the next event is past the wait duration and there's no point in waiting\n    // further\n    const timer     = global.setTimeout(timeout, waitDuration);  // eslint-disable-line no-use-before-define\n    const timeoutOn = Date.now() + waitDuration;\n\n    // Fired after every event, decide if we want to stop waiting\n    function ontick(next) {\n      // No point in waiting that long\n      if (next >= timeoutOn) {\n        timeout();\n        return;\n      }\n\n      const activeWindow = eventLoop.active;\n      if (completionFunction && activeWindow.document.documentElement)\n        try {\n          const waitFor   = Math.max(next - Date.now(), 0);\n          // Event processed, are we ready to complete?\n          const completed = completionFunction(activeWindow, waitFor);\n          if (completed)\n            done();\n        } catch (error) {\n          done(error);\n        }\n\n    }\n\n    // The wait is over ...\n    function done(error) {\n      global.clearTimeout(timer);\n      eventLoop.removeListener('tick', ontick);\n      eventLoop.removeListener('idle', done);\n      eventLoop.browser.removeListener('error', done);\n\n      --eventLoop.waiting;\n      try {\n        callback(error);\n      } catch (error) {\n        // If callback makes an assertion that fails, we end here.\n        // If we throw error synchronously, it gets swallowed.\n        setImmediate(function() {\n          throw error;\n        });\n      }\n    }\n\n    // We gave up, could be result of slow response ...\n    function timeout() {\n      if (eventLoop.expected)\n        done(new Error('Timeout: did not get to load all resources on this page'));\n      else\n        done();\n    }\n\n    eventLoop.on('tick', ontick);\n\n    // Fired when there are no more events to process\n    eventLoop.once('idle', done);\n\n    // Stop on first error reported (document load, script, etc)\n    // Event loop errors also propagated to the browser\n    eventLoop.browser.once('error', done);\n  }\n\n\n  dump(output = process.stdout) {\n    if (this.running)\n      output.write('Event loop: running\\n');\n    else if (this.expected)\n      output.write(`Event loop: waiting for ${this.expected} events\\n`);\n    else if (this.waiting)\n      output.write('Event loop: waiting\\n');\n    else\n      output.write('Event loop: idle\\n');\n  }\n\n\n  // -- Event queue management --\n\n  // Creates and returns a new event queue (see EventQueue).\n  createEventQueue(window) {\n    return new EventQueue(window);\n  }\n\n  // Set the active window. Suspends processing events from any other window, and\n  // switches to processing events from this window's queue.\n  setActiveWindow(window) {\n    if (window === this.active)\n      return;\n    this.active = window;\n    this.run(); // new window, new events?\n  }\n\n  // Are there any expected events for the active window?\n  get expected() {\n    return this.active && this.active._eventQueue.expected;\n  }\n\n\n  // -- Event processing --\n\n  // Grabs next event from the queue, processes it and notifies all listeners.\n  // Keeps processing until the queue is empty or all listeners are gone. You\n  // only need to bootstrap this when you suspect it's not recursing.\n  run() {\n    // A lot of code calls run() without checking first, so not uncommon to have\n    // concurrent executions of this function\n    if (this.running)\n      return;\n    // Is there anybody out there?\n    if (this.waiting === 0)\n      return;\n\n    // Give other (Node) events a chance to process\n    this.running = true;\n    setImmediate(()=> {\n      this.running = false;\n      try {\n\n        // Are there any open windows?\n        if (!this.active) {\n          this.emit('idle');\n          return;\n        }\n        // Don't run event outside browser.wait()\n        if (this.waiting === 0)\n          return;\n\n        const jsdomQueue  = idlUtils.implForWrapper(this.active.document)._queue;\n        const event       = this.active._eventQueue.dequeue();\n        if (event) {\n          // Process queued function, tick, and on to next event\n          event();\n          this.emit('tick', 0);\n          this.run();\n        } else if (this.expected > 0)\n          // We're waiting for some events to come along, don't know when,\n          // but they'll call run for us\n          this.emit('tick', 0);\n        else if (jsdomQueue.tail) {\n          jsdomQueue.resume();\n          this.run();\n        } else {\n          // All that's left are timers, and not even that if next == Infinity\n          const next = this.active._eventQueue.next;\n          if (isFinite(next))\n            this.emit('tick', next);\n          else\n            this.emit('idle');\n        }\n\n      } catch (error) {\n        this.emit('error', error);\n      }\n    });\n  }\n\n};\n"]}